<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magnetic Growth Orb v2</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Cormorant:wght@500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --accent-magnet: #FF6B6B;
            --field-teal: #00FFE0;
            --dark-bg: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
        }

        body {
            margin: 0;
            background: var(--dark-bg);
            color: white;
            font-family: 'Inter', sans-serif;
            min-height: 100vh;
        }

        #hero {
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        .hero-content {
            position: relative;
            z-index: 2;
            text-align: center;
            padding: 2rem;
            max-width: 1200px;
        }

        .headline {
            font-family: 'Cormorant', serif;
            font-size: 4rem;
            margin: 0 auto 2rem;
            background: linear-gradient(45deg, var(--accent-magnet), var(--field-teal));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            line-height: 1.1;
        }

        .subheadline {
            font-size: 1.5rem;
            max-width: 600px;
            margin: 0 auto 3rem;
        }

        .cta-button {
            padding: 1.2rem 3rem;
            font-size: 1.2rem;
            background: rgba(255, 107, 107, 0.15);
            border: 2px solid var(--accent-magnet);
            color: white;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .cta-button:hover {
            background: rgba(255, 107, 107, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255,107,107,0.3);
        }
    </style>
</head>
<body>
    <section id="hero">
        <canvas id="scene"></canvas>
        <div class="hero-content">
            <h1 class="headline">Magnetic Growth Engine</h1>
            <p class="subheadline">
                Attracting <span style="color: #FF6B6B">leads</span>, 
                <span style="color: #00FFE0">customers</span>, and 
                <span style="color: #FFD700">profits</span> effortlessly
            </p>
            <button class="cta-button">Activate Magnetic Growth</button>
        </div>
    </section>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        class MagneticScene {
            constructor() {
                this.container = document.getElementById('scene');
                this.initScene();
                this.createOrb();
                this.createParticles();
                this.createField();
                this.animate();
                this.handleResize();
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, 
                    window.innerWidth/window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.container,
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.camera.position.z = 8;

                const ambient = new THREE.AmbientLight(0xffffff, 0.5);
                this.scene.add(ambient);
                
                const directional = new THREE.DirectionalLight(0xffffff, 1);
                directional.position.set(5, 5, 5);
                this.scene.add(directional);
            }

            createOrb() {
                this.orbMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x9b59b6,
                    metalness: 0.9,
                    roughness: 0.1,
                    clearcoat: 1.0,
                    clearcoatRoughness: 0.1,
                    emissive: 0x00FFE0,
                    emissiveIntensity: 0.8
                });

                this.geometry = new THREE.IcosahedronGeometry(1.5, 64);
                this.orb = new THREE.Mesh(this.geometry, this.orbMaterial);
                this.scene.add(this.orb);
            }

            createParticles() {
                const particleCount = 1000;
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                
                for (let i = 0; i < particleCount; i++) {
                    // Position
                    positions[i*3] = (Math.random() - 0.5) * 20;
                    positions[i*3+1] = (Math.random() - 0.5) * 20;
                    positions[i*3+2] = (Math.random() - 0.5) * 20;
                    
                    // Colors
                    const color = new THREE.Color();
                    const type = Math.floor(Math.random() * 3);
                    color.setHex(type === 0 ? 0xFF6B6B : type === 1 ? 0x00FFE0 : 0xFFD700);
                    colors[i*3] = color.r;
                    colors[i*3+1] = color.g;
                    colors[i*3+2] = color.b;
                }

                this.particleGeometry = new THREE.BufferGeometry();
                this.particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                this.particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                this.particleMaterial = new THREE.PointsMaterial({
                    size: 0.25,
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.9
                });

                this.particles = new THREE.Points(this.particleGeometry, this.particleMaterial);
                this.scene.add(this.particles);
            }

            createField() {
                const curve = new THREE.EllipseCurve(
                    0, 0,
                    3, 1.5,
                    0, Math.PI * 2,
                    false,
                    0
                );

                const points = curve.getPoints(50);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                
                this.fieldLine = new THREE.Line(geometry, new THREE.LineBasicMaterial({
                    color: 0x00FFE0,
                    transparent: true,
                    opacity: 0.6
                }));
                
                this.fieldLine.rotation.x = Math.PI/2;
                this.scene.add(this.fieldLine);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const time = Date.now() * 0.001;
                
                // Orb rotation
                this.orb.rotation.y += 0.002;
                
                // Particle animation
                const positions = this.particles.geometry.attributes.position.array;
                const colors = this.particles.geometry.attributes.color.array;
                
                for (let i = 0; i < positions.length; i += 3) {
                    const dx = this.orb.position.x - positions[i];
                    const dy = this.orb.position.y - positions[i+1];
                    const dz = this.orb.position.z - positions[i+2];
                    const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    // Attraction force
                    const force = 0.0005 * (1 / Math.pow(distance, 1.5));
                    
                    positions[i] += dx * force;
                    positions[i+1] += dy * force;
                    positions[i+2] += dz * force;

                    // Reset when too close
                    if (distance < 0.3) {
                        positions[i] = (Math.random() - 0.5) * 20;
                        positions[i+1] = (Math.random() - 0.5) * 20;
                        positions[i+2] = (Math.random() - 0.5) * 20;
                    }
                }
                this.particles.geometry.attributes.position.needsUpdate = true;

                // Field animation
                this.fieldLine.rotation.z = Math.sin(time) * 0.2;
                this.fieldLine.material.opacity = Math.sin(time * 3) * 0.3 + 0.4;

                this.renderer.render(this.scene, this.camera);
            }

            handleResize() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }
        }

        window.addEventListener('load', () => new MagneticScene());
    </script>
</body>
</html>
